import{f as d,ct as k,cs as R,$ as N,bl as j,cu as x,cv as l,cw as P,aB as b,cx as w,cy as O,h,ar as c,aN as S,aO as _,I as A,b3 as v,bj as T,cz as y,cA as B}from"./ohOm73aH.js";const E=d({name:"LayoutLoader",inheritAttrs:!1,props:{name:String,layoutProps:Object},setup(t,s){return()=>c(l[t.name],t.layoutProps,s.slots)}}),C={name:{type:[String,Boolean,Object],default:null},fallback:{type:[String,Object],default:null}},U=d({name:"NuxtLayout",inheritAttrs:!1,props:C,setup(t,s){const o=k(),u=b(y),e=!u||u===R()?P():u,a=N(()=>{let n=h(t.name)??(e==null?void 0:e.meta.layout)??"default";return n&&!(n in l)&&t.fallback&&(n=h(t.fallback)),n}),i=j();s.expose({layoutRef:i});const r=o.deferHydration();if(o.isHydrating){const n=o.hooks.hookOnce("app:error",r);x().beforeEach(n)}let f;return()=>{const n=a.value&&a.value in l,p=(e==null?void 0:e.meta.layoutTransition)??w,L=f;return f=a.value,O(n&&p,{default:()=>c(A,{suspensible:!0,onResolve:()=>{_(r)}},{default:()=>c(H,{layoutProps:S(s.attrs,{ref:i}),key:a.value||void 0,name:a.value,shouldProvide:!t.name,isRenderingNewLayout:m=>m!==L&&m===a.value,hasTransition:!!p},s.slots)})}).default()}}}),H=d({name:"NuxtLayoutProvider",inheritAttrs:!1,props:{name:{type:[String,Boolean]},layoutProps:{type:Object},hasTransition:{type:Boolean},shouldProvide:{type:Boolean},isRenderingNewLayout:{type:Function,required:!0}},setup(t,s){const o=t.name;t.shouldProvide&&v(B,{isCurrent:e=>o===(e.meta.layout??"default")});const u=b(y);if(u&&u===R()){const e=P(),a={};for(const i in e){const r=i;Object.defineProperty(a,r,{enumerable:!0,get:()=>t.isRenderingNewLayout(t.name)?e[r]:u[r]})}v(y,T(a))}return()=>{var e,a;return!o||typeof o=="string"&&!(o in l)?(a=(e=s.slots).default)==null?void 0:a.call(e):c(E,{key:o,layoutProps:t.layoutProps,name:o},s.slots)}}});export{U as _};
